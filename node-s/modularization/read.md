#### 模块化
    目标：
    1、模块化的好处
    2、CommonJs规定了哪些内容
    3、Node.js中的模块的三大分类是什么
    4、能够使用NPM管理包
    5、了解什么是规范的包结构
    6、了解模块化的加载机制

#### 模块化的基本概念
    模块化是值在解决一个复杂问题的时，自顶向下逐层把系统划分为若干模块的过程中，对整个系统来说，模块化是可组合、分解和更换的单元

    编程领域中的模块化，就是遵守固定柜子，把一个大文件拆成独立并相互依赖的多个小模块

    代码进行模块还好处：
    1.提高了代码的复用性
    2.提高了代码的可维护性
    3.可以实现按需加载

#### 模块化规范
    node.js遵循了CommonJS模块化规范，CommonJS规定了模块的特性和各个模块之间的如何相互依赖
    CommonJS规定：
    1、每个模块内部，module 变量代表当前模块
    2、module变量是一个对象，他的exports属性（即module.exports）是对外的借口
    3、加载某个模块，其实是加载该模块的module.exports属性，require()方法用于加载模块


#### node.js中的模块化
    node.js中模块的分类：
    node.js中根据模块的来源的不同，将模块化分为了3个大类，分别是：
    1、内置模块（内置模块是由 Node.js官方提供的，例如fs、path、http、等）
    2、自定义模块（用户创建的每个.js文件，都是自定义模块）
    3、第三方模块（由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，使用前需先下载）

    加载模块
    1、使用require()方法，可以按需加载需要的内置模块、自定义模块和第三方模块进行使用，例如：...
    注意：在使用require()方法加载其他模块时，会执行被加载模块中的代码

    模块作用域
    和函数作用域类似，在自定义模块中定义的变量，方法等成员，只能在当前模块内被访问，这种模块级别的访问限制叫做模块作用

    模块作用域好处：
    1、防止全局变量污染问题

#### 向外共享模块作用域中的成员
    1、module对象
    在每个.js自定义模块中都有一个module对象，它里面存储了和当前模块有关的信息，
    2、module.exports对象
    在自定义模块中，可以使用module.exports 对象，将模块内的成员共享出去，供外界使用。外界用require()方法导入自定义模块时，得到的就是module.exports所指的对象
    注意：使用require()方法导入模块是，导入结果，永远以module.exports 只想的对象为准
    3、exports对象
    由于module.exports写起来复杂，为了简化向外共享成员代码，node提供了exports对象，默认情况下，exports和module.exports指向同一个对象，最终共享结果，还是以module.exports指向的对象为准
    4、export和module.exports的使用误区
    注意：require()方法导入模块永远指向module.exports指向的对象

#### npm与包
    1、包：
    node.js的第三方模块又叫包
    2、包的来源：
    不同于node.js中的内置模块与自定义模块，包是由第三方个人或团队开发出来的，免费供所有人使用
    注意：node.js中的包都是免费且开源的，不需要付费即可免费下载使用
    3、为什么使用包
    包是基于内置模块封装出来的，提供了更高级、更方便的API，极大的提高了开发效率
    4、从哪里下载包 
    [用来检索需要的包](https://www.npmjs.com/)
    [用来下载所需要的包]()
    5、如何下载包
    npm，lc公司提供了包管理工具npm(node pakage manage),这个包管理工具随着node.js的安装包一起被安装，npm -v 查看npm版本
    monent 格式化时间包
    6、 在项目中安装包
        npm i 包的名称
        npm i 包名称@2.22.2 通过@加版本号制定安装包的版本

    7、初次安装包后，项目文件中多了一个叫做node_modules的文件夹和package-lock.json的配置文件
    其中：
    node_modules文件夹用来存放所有已安装到项目中的包，require()导入的第三方包时，就是从这个目录中查找并加载包
    package-lock.json配置文件用来记录node_modules目录下的每个包的下载信息，例如包的名称、版本号、下载地址等

    8、包语义化版本规范
    包的版本号是以“点分十进制”形式进行定义的，总共有三位数字，例如 2.24.0
    每一位数字代表的含义：
    第一位数字：大版本，
    第二位数字：功能版本
    第三位数字：bug修复版本
    版本号的提升规则，只要前面的版本号增长，后面的版本号则要归零

#### 包管理配置文件
    1、npm规定，在项目根目录中，必须提供一个叫做package.json的包管理配置文件，用来记录与项目相关的一些配置信息，例如：
    项目的名称，版本号，描述及项目中所用的包，并且可以记录哪些包在开发期间会用，哪些包在开发和部署都需要用到

    2、多人协作问题
    在项目根目录，需要创建package.json来记录项目中安装的包，从而剔除node_modules，在成员中共享源代码
    项目开发中，需要将node_modules放到.gitignore忽略文件中

    3、快速创建packge.json
    npm init -y 在所在的目录快速创建,注意：该命令只能在英文的目录下进行执行

    4、 dependencies 节点
    package.json 文件汇总，有一个dependencies节点，专门用来记录使用npm install 命令安装的包的信息

    5、一次性安装所有包
    npm install(npm i)一次性下载所有包

    6、 卸载包
    npm uninstall 包名称

    7、devDependencies节点
    如果某些包只在项目开发阶段会用到，在项目上线之后不会用到，则建议八这些包记录到这个节点当中
    npm i 包名 -D

    8、 为什么下包速度慢
     在使用npm下载包的时候，默认是从国外的http://registry.npmjs.org服务器进行下载,此时网络数据的传输需要结果漫长的海底光缆，因此下包速度慢

    9、 淘宝NPM镜像服务器
    淘宝在国内搭建了一个服务器，专门把国外官方服务器上的包同步到国内的服务器，然后在国内提供下包服务，从而极大的提高了下包速度
    扩展：镜像(Mirroring)是一种文件存储形式，一个磁盘上的数据在另一个磁盘上存在一个完全相同的副本即位镜像

    10、写还npm的下包镜像源
    下包的镜像源，指的就是下包的服务器地址。
     #查看当前的下包镜像
     npm config get registry
     #将下包镜像切换为淘宝镜像
     npm config set registry=https://registy.npmmirror.org/
     #检查是否下载成功
     npm config get registry

     11、nrm
     为了可以更加方便的切换下包镜像源，可以安装nrm工具，进行终端命令快速查看和切换下包的镜像源
     #安装nrm
     npm i nrm -g
     #查看所有可用的镜像源
     nrm ls
     #切换下包的镜像源
     nrm use taobao(镜像的代表名称)

     12、包的分类
     哪些被安装到项目的node_modules目录的包，都是项目包

     项目包分为两类：
     开发依赖包(被记录到devDenpendencies节点的包，只在开发期间会用到)
     核心依赖包(被记录到dependencies节点的包，在开发期间和项目上线之后都会用到)

     全局包
     在执行npm install 命令是，如果提供了-g参数，则会把安装包安装为全局包
     全局包默认会被安装到（使用npm ls -g 查看）
     注意：
     只有工具性质的包，才有全局安装的必要性，因为它提供了好用的终端命令
     判断某个包是否需要全局安装后才能使用，可以参考官方提供的使用说明即可

     13、 i5ting_toc
     i5ting_toc 是一个可以吧md文档转为html页面的小公举，使用步骤：
     #将i5ting_toc 安装为全局包
     npm install -g i5ting_toc
     #调用i5ting_toc ，轻松实现md转html功能
     i5ting_toc -f 要转换的md文件路径 -o

     14、 规范的包结构
     一个规范的包，他的组织结构，必须符合以下3点要求：
     （1）包必须以独立的目录而存在
     （2）包的顶级目录下必须要包含package.json这个包管理配置文件
     （3）package.json中必须包含name、version、main这三个属性。分别代表包的名称、版本号、包的入口

#### 如何开发一个属于自己的包（roundlee-tools 目录）
    1、需要实现的功能
    格式化日期
    转义HTMl中的特殊字符
    还原HTML中的特殊字符

    2、初始化包的基本结构
    新建roundlee-tools文件夹，作为包的根目录
    在roundlee-tools文件夹下，新建如下三个文件：
        package.json（包管理配置文件）
        index.js （包的入口文件）
        README.md (包说明文档)
    初始化package.json 文件

    3、将不同功能进行模块化拆分，最终通过index.js 文件抛出

    4、编写说明文档
    README.md 文件是包的说明文档，主要包含以下6项
    安装方式、导入方式、格式化时间、转义html中的特殊字符、还原html中的特殊字符、开源协议

    5、注册npm账号，并在终端执行 npm login命令进行登录
    
    6、 把包发布到npm上
    将终端切换到根目录后，运行npm publish  命令，即可将包发布到npm上,注意：包名不能雷同

    7、删除已发布的包
    运行npm unpublish 包名 --force 命令，即可从npm 删除已发布的包
    注意：npm unpublish 命令只能删除72小时以内发布的包
        npm  unpublish 删除的包，在24小时内不允许重复发布
        发布包要慎重，尽量不要网npm上发布没有意义的包

#### 模块的加载机制
    1、优先缓存中加载 多次require() 不会进行多次执行
    2、内置模块的加载优先级最高
    3、自定义模块 必须以./或../开头的路径表示，不然会被当作内置模块或第三方模块进行加载
    在使用require 导入自定义模块是，如果省略的文件扩展名，则node.js会按顺序分别尝试加载一下文件：
        按照确切的文件名进行加载
        补全.js扩展名进行加载
        补全.json扩展名进行加载
        补全.node扩展名进行加载
        加载失败
    如果传递给require的模块标识符不是一个内置模块，也没有./或../开头，则node.js会从当前模块的父目录开始，尝试从/node_modules文件夹中加载第三方模块，如果没找到第三方模块，则会移动到上一层父目录中进行加载，知道文件系统的根目录
    4、把目录作为模块标识符，传递给require()进行加载的时候，有三种方式
        （1）在被加载的目录下查找一个叫做package.json的文件，并寻找main属性，作为require()加载的入口
        （2）如果目录中没有package.json文件，或者main入口不存在或无法解析，则node.js将会试图加载目录下的index.js文件
        （3）如果以上两步都失败了，则node.js会在终端打印错误信息，报告模块的缺失：Error:Cannot find module 'xxx'













