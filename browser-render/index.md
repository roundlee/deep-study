### 浏览器渲染原理
浏览器是如何渲染页面的
>```
>    当浏览器的网络线程收到HTML文档后，会产生一个渲染任务，并将其传递给其他主线程的消息队列，在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程
>    整个渲染流程分为多个阶段，分别是：HTML解析、样式计算、布局、分层、绘制、分块、光栅化、画。每个阶段都有明确的输入输出，上个阶段的输出会成为下个阶段的输入，这样整个渲染流程形成了一条组织严密的生产流水线
>```
##### 浏览器渲染流程
##### 一、解析HTML--Parse HTML  
>```
>    解析过程中遇到 CSS 解析 CSS，遇到js执行js。为了提高效率，浏览器解析前，会启动一个预解析的线程，率先下载外部css文件和外部的js文件
>    如果主线程解析道link位置，此时外部的css文件还没有下载解析好，主线程不会等待，继续解析后续的HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的，这就是css不会阻塞HTML解析的根本原因
>    如果主线在解析到了script位置，会停止解析HTML，转而等待js文件下载好，将全局的代码解析执行完成后，才能继续解析HTML，这是因为js代码的执行过程中可能会修改当前的DOM树，所以DOM树的生成必须暂停，这就是js会阻塞的根本原因
>```
* dom树

* cssom树 更节点代表所有的样式表
>```
> 1. style：内部样式表
> 2. link：外部王式表
> 3. <div style="">：内联样式表
> 4. 浏览器默认样式表 user angent styleSheetList

问题解析过程中遇到css怎么办：
* 为了提高解析效率，浏览器会启动预解析器率先下载和解析css，js

##### 二、样式计算 RecalculateStyle
>```
>主线程会遍历得到DOM树，依次为树中的每个节点计算出它的最终样式，称之为 Computed Style。
>在这个过程中，很多预设值会变成绝对值，比如red变成rgb(255,0,0)；相对单位会变成绝对单位，比如em变成px
>```
* 题外话：这个阶段就包括css的属性计算过程(层叠、继承、)；视觉格式话模型(盒模型、包含快)
* 形成最终样式即计算后的样式 computed Style

##### 三、布局 - Layout
>```
>布局阶段会依次遍历DOM树的每个节点，计算每个节点的集合信息，例如节点的宽高、相对包含块的位置
>大部分的时候，DOM树和布局树并非一一对应。比如display:none；的节点没有几何信息，因此不会生成到布局树，又比如伪选择器，虽然DOM中不存在这些伪元素的节点，但他们拥有几何信息，所以会生成到布局树。还有匿名行盒、匿名块盒等等都会导致DOM树和布局树无法一一对应
>```
  两个主要点 尺寸、包含块

##### 四 分层 - layer
>```
>主线程会使用一套复杂的策略对整个布局树进行分层。
>分层的好处在于，将来某个层改变后，仅对该层进行后续处理，从而提升效率，
> 滚动条、堆叠上下文、transform、opacity等等样式都会或多或少的影响分层结果，也可以通过will-change属性更大程度的影响分层结果
>```
 题外话：堆叠上下文相关属性(z-index、opacity、transform、)

##### 五 绘制 - paint （渲染主线程的动作到此结束，剩余步骤交与其他线程进行处理）
>```
>主线程会为每个层产生单独指令，用于描述这一层如何画出来
>完成绘制后，主线程会将每个图层的绘制信息交给合成线程，剩余工作将由合成线程完成
>合成线程后弦对每个图层进行分块，将其划分成更小的区域，它会从线程池中拿取多个线程来完成分块工作
>```

* 相关点 形成指令集
* 题外话 canvas


##### 六 分块 - Tiling （合成线程(compositor)：启动更多的线程(分块线程、)）

##### 七 光栅化 - Raster （GPU 进程）
>```
>分块完成后会进入光栅化阶段
>合成线程会将分块信息交给GPU进程，以极高的速度完成光栅化
>GPU进程会开启多个线程来进行光栅化，并优先处理靠近适口区域的块。
>光栅化的结果就是一个一个位图
>```
此过程会用到GPU加速
* 将每个块变成位图
* 优先处理靠近视口的块

##### 八 画 - Draw
>```
>合成线程拿到每个层、每个块的位图后，生成一个个(指引quad)信息
>指引会标识出每个位图应该化到屏幕的哪个位置，以及会考虑旋转、缩放等变形，变形发生在合成线程里，与渲染主线程无关，这就是transform效率高的根本原因
>合成线程会把quad交给GPU进程，由GPU进程产生系统调用，提交给GPU硬件，完成最终的屏幕呈现
>```
* 合成线程计算出每个位图在屏幕上的位置，交给GPU进行最终呈现
题外话：渲染进程在沙盒里面，保证安全性

面试题：
* 什么是 reflow
>```
>reflow的本质就是重新计算layout树。
>当进行了会影响布局树的操作后，需要重新计算布局树，会引发layout
> 为了避免连续多次操作导致布局树反复计算，浏览器会合并这些操作，当js代码全部完成后再进行统一计算，所以改动属性造成的reflow的异步完成的
>也同样如此，当js获取布局信息时，就有可能导致无法获取到最新的布局信息，浏览器在反复权衡下，最终决定获取属性立即执行felow
>```
* 什么是 repaint
>```
>本质就是重新根据分层信息计算了的绘制指令，当改动了可见样式后，就是要重新计算，产生epaint，由于元素布局也属于可见样式，所以reflow必定引起repaint
>```
* 为什么 transform 效率高
>```
>因为transform既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个阶段(draw) 阶段，由于draw阶段在合成线程中，所以transform的变化几乎不会影响渲染主线程，反之渲染主线程无论如何忙碌也不会影响到transform的变化
>```